
#include <random>
#include <stdio.h>


//        5, 7,  15, 4,   0, 3,   11, 9,  12, 8,  1, 14, 13, 2, 6, 10

//step 1: [5 7]  [4 15]   [0 3]   [9 11]  [8 12]  [1 14] [2 13] [6 10]
//step 1之后相邻两个一组，两两排序，两个里面都正序排列

//step 2,   4个一组，
//round 1，每4个1组里，第一个与最后一个比较，第二个与倒数第二个比较，如此，5和15比，7和4比, 
//round 2, 再两个1组两两比较
//step 2之后相邻每四个一组，组内正序排列

//          ______
//         |      |
//round 1 [5 4 7 15]  [0 3 9 11]   [8 1 12 14]    [2 6 13 10]
//           |_|

//round 2 [4 5][7 15] [0 3][9 11]  [1 8] [12 14]  [2 6] [10 13]

//step 3,round 1,8个1组比较，round 2, 4个1组比较，round 3，两个1组比较
//round 1 第1个和倒数第一个比较，第二个和倒数第二个比较，round 2开始是间隔1个比较
//step 3之后，相邻每8个一组，组内正序排列，

//           _______________
//          |               |
//round 1  [4 5 3 0 15 7 9 11]         [1 8 6 2  14 12 10 13]
//            |__________|
//           ___
//          |   |
//round 2  [3 0 4 5]    [9 7 15 11]    [1 2 6 8]   [10 12 14 13]
//            |___|

//round 3  [0 3] [4 5]  [7 9] [11 15]  [1 2] [6 8] [10 12] [13 14]


//step 4, round 1, 16个1组比较，round 2，8个1组比较，round 3，4个1组比较，round 4，2个1组比较
//round 1 第1个和倒数第一个比较，第二个和倒数第二个比较，round 2开始是间隔1个比较
//            ____________________________________________________________
//           |                                                            |
//round 1:  [ 0  3  4  5   7  6  2   1    15    11  9  8   10  12   13   14 ]
//               |___________________________________________________|
//              _____________
//             |             |
//round 2    [ 0  3 2 1      7  6 4 5 ]  [10 11 9 8  15 12 13 14]
//                |_____________|

//round 3    [0  1 2 3]    [4  5 7  6]  [9 8  10 11]   [13 12 15 14]
//round 4    [0 1] [2 3]   [4 5] [6 7]  [8 9] [10 11]  [12 13] [14 15]


void bitonic(unsigned int *data, int N)
{
	int i;//遍历step
	int j;//遍历round
	int k; //遍历group
	int l; //遍历group里每对数据
	int ii;

	int steps = log2(N);
	int groups;
	int rounds;
	int pairs; //一组有几对数据
	int M; //一组有几个数据,M=2*pairs

	for (i = 1; i <= steps; i++){
		rounds = i;
		for (j = 0; j < rounds; j++){
			//step1,rounds=1,groups=1,
			//step2,rounds=2,j=0,groups=4,j=1,groups=8
			//step3,rounds=3,j=0,groups=2,j=1,groups=4,j=2,groups=8
			groups = N/(1<<(rounds-j));
			M = N/groups;
			pairs = M/2;
			for (k = 0; k < groups; k++){

				for (l = 0; l < pairs; l++){
					if (j == 0){
						if (data[k*M + l] >= data[(k + 1)*M - l-1]) //只有round 1 是组内第一点和最后一点，第二点和倒数第二点这样比较
						{
							int temp = data[k*M + l];
							data[k*M + l] = data[(k + 1)*M - l-1];
							data[(k + 1)*M - l-1] = temp;
						}
					}
					else{
						if (data[k*M + l] >= data[k*M +M/2+l]) //round 2之后都是间隔M/2-1点之间的比较
						{
							int temp = data[k*M + l];
							data[k*M + l] = data[k*M + M / 2 + l];
							data[k*M + M / 2 + l] = temp;
						}
					}


				}
			}

			printf("step %2d round %2d: ",i,j+1);
			for (ii = 0; ii < N; ii++){
				printf("%4d ",data[ii]);
			}
			printf("\n");
		}
	}
}


//另一种实现，和第一种区别是组内没有第一个与最后一个比较，第二个与倒数第二个比较，取数规律都是一样的,这种适合fpga实现
//但是比较有正序和逆序

//        5, 7,  15, 4,   0, 3,   11, 9,  12, 8,  1, 14, 13, 2, 6, 10

//         正      逆       正       逆    正      逆       正    逆
//step 1: [5 7]  [15 4]   [0 3]   [11 9]  [8 12]  [14 1] [2 13] [10 6]

//step 2,   4个数正，4个数逆，交替

//           正          逆           正              逆
//round 1 [5 4 15 7]  [11 9 0 3]   [8 1 14 12]    [10 13 2 6]
//         正   正      逆    逆    正     正       逆    逆
//round 2 [4 5][7 15] [11 9][3 0]  [1 8] [12 14]  [13 10] [6 2]


//step 3,8个数正，8个数逆

//                  正                       逆
//round 1  [4 5 3 0    11 9 7  15]    [13 10 12 14    1 8 6 2]
//            正          正                逆          逆
//round 2  [3 0 4 5]   [7 9 11 15]    [13 14 12 10]   [6 8 1 2]
//          正   正      正   正        逆     逆       逆  逆
//round 3  [0 3][4 5]  [7 9][11 15]  [14 13][12 10]  [8 6][2 1]


//step 4, 16个数正，16个数逆，也就是全部正
//round 1:  [ 0  3  4  5   7  6  2 1    14  13  12  10  8  9  11 15 ]
//round 2    [ 0  3 2 1    7  6 4 5 ]  [8 9 11 10    14 13 12 15]
//round 3    [0  1 2 3]    [4  5 7  6]  [8 9  11 10]  [12 13 14 15]
//round 4    [0 1] [2 3]   [4 5] [6 7]  [8 9] [10 11]  [12 13] [14 15]


void bitonic2(unsigned int *data, int N)
{
	int i;//遍历step
	int j;//遍历round
	int k; //遍历group
	int l; //遍历group里每对数据
	int ii;

	int steps = log2(N);
	int groups;
	int rounds;
	int pairs;         //一组有几对数据
	int M;             //一组有几个数据,M=2*pairs
	int ascend;        //1=升序 0=降序

	for (i = 1; i <= steps; i++){
		rounds = i;
		//step 1,最大组2个数据，
		//step 2,最大组4个数据
		//...
		for (j = 0; j < rounds; j++){
			//step 1,rounds=1,groups=1,
			//step 2,rounds=2,j=0,groups=4,j=1,groups=8
			//step 3,rounds=3,j=0,groups=2,j=1,groups=4,j=2,groups=8
			groups = N / (1 << (rounds - j));
			M = N / groups;
			pairs = M / 2;
			for (k = 0; k < groups; k++){
				//round 1, k第0bit决定升降
				//round 2, k第1bit决定升降
				//...
				ascend = ((k >> j) & 0x1) ==0;
				for (l = 0; l < pairs; l++){
					int swap = ascend ? data[k*M + l] >= data[k*M + M / 2 + l] :
						data[k*M + l] <= data[k*M + M / 2 + l];
					if (swap)
					{
						int temp = data[k*M + l];
						data[k*M + l] = data[k*M + M / 2 + l];
						data[k*M + M / 2 + l] = temp;
					}



				}
			}

			printf("step %2d round %2d: ", i, j + 1);
			for (ii = 0; ii < N; ii++){
				printf("%4d ", data[ii]);
			}
			printf("\n");
		}
	}
}




//随机打乱数组中的数
void knuth(unsigned int *arr,int n)
{
	int i;

	for (int i = 0; i<n; i++)
	{
		int r = rand();
		int a = r%(n - i);
		int temp = arr[a];
		arr[a] = arr[n-1-i];
		arr[n - 1 - i] = temp;
	}
}


unsigned int mem[2048] = { 113, 38, 170, 190, 177, 246, 186, 111, 251, 79, 121, 2, 185, 91, 112, 90, 219, 
132, 204, 95, 69, 205, 237, 54, 172, 81, 138, 143, 33, 18, 224, 43, 117, 244, 86, 217, 24, 247, 10, 83,
124, 230, 233, 200, 136, 151, 122, 46, 181, 85, 131, 127, 14, 70, 163, 254, 213, 249, 193, 30, 120, 13, 
128, 212, 137, 32, 65, 201, 116, 40, 144, 159, 28, 142, 240, 73, 75, 236, 102, 68, 45, 4, 64, 103, 179, 
108, 92, 243, 169, 55, 182, 98, 106, 82, 168, 234, 6, 44, 20, 0, 80, 175, 52, 135, 61, 62, 199, 198, 145,
166, 150, 133, 100, 51, 97, 214, 192, 148, 84, 149, 180, 58, 250, 223, 25, 130, 114, 63, 94, 160, 229, 245,
16, 49, 253, 50, 207, 152, 5, 206, 48, 203, 53, 140, 35, 57, 42, 1, 71, 27, 154, 156, 216, 157, 239, 232, 
56, 218, 15, 118, 184, 29, 76, 26, 99, 12, 89, 155, 109, 36, 255, 176, 252, 72, 248, 221, 8, 197, 134, 183, 
226, 195, 141, 66, 125, 104, 209, 88, 235, 194, 119, 96, 105, 202, 227, 164, 208, 7, 189, 123, 196, 241, 74,
210, 174, 3, 37, 173, 187, 21, 220, 77, 87, 78, 161, 191, 129, 31, 19, 147, 22, 93, 165, 211, 126, 23, 146, 110, 
167, 171, 139, 242, 153, 158, 34, 59, 222, 67, 231, 115, 9, 39, 60, 101, 215, 47, 11, 178, 225, 228, 162, 17, 188, 238, 107, 41, };
//unsigned int mem[16] = { 5, 7, 15, 4, 0, 3, 11, 9, 12, 8, 1, 14, 13, 2, 6, 10 };


extern void bitonic_fpga(unsigned int *data, int N);

int main()
{
	int N = 2048;
	int i;
	for (i = 0; i < N; i++)
		mem[i] = i;
	knuth(mem, N);
	printf("                   ");
	for (i = 0; i < N; i++){
		printf("%4d ", i);
	}
	printf("\n");



	printf("data:              ");
	for (i = 0; i < N; i++){
		printf("%4d,",mem[i]);
	}
	printf("\n");

	
	for (i = 0; i < N/2; i++){
		printf("{50'd%d,50'd%d},", mem[2 * i + 1], mem[2 * i]);
		if (i % 8 == 7)
			printf("\n");
	}
	printf("\n");



	bitonic_fpga(mem, N);
	return 0;
}

